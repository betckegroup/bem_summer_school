
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Tree partitioning &#8212; BEM Summer School - Lecture Notes</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=62ba249389abaaa9ffc34bf36a076bdc1d65ee18" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=f31d14ad54b65d19161ba51d4ffff3a77ae00456"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Low rank compressibility" href="low_rank_compression.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">BEM Summer School - Lecture Notes</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="intro.html">
                    BEM Summer School Lecture Notes
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Fast direct solvers
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="low_rank_compression.html">
   Low rank compressibility
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Tree partitioning
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://mybinder.org/v2/gh/executablebooks/jupyter-book/master?urlpath=tree/partitioning.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Binder"
>
  

<span class="headerbtn__icon-container">
  
    <img src="_static/images/logo_binder.svg">
  </span>
<span class="headerbtn__text-container">Binder</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="_sources/partitioning.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#cluster-trees">
   Cluster Trees
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#octrees">
   Octrees
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Tree partitioning</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#cluster-trees">
   Cluster Trees
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#octrees">
   Octrees
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="tree-partitioning">
<h1>Tree partitioning<a class="headerlink" href="#tree-partitioning" title="Permalink to this headline">#</a></h1>
<p>In this section we discuss partitioning strategies for our computational domain that let us sort our sources and targets into admissible and non-admissible pairs.</p>
<p>Historically, Hierarchical Matrix methods use binary cluster trees to partition the computational domain, and Fast Multipole Methods use partitioning based on Octrees. In the following we will discuss both types of trees.</p>
<p>Before we talk about these two types of trees let us remind of the mathematical definition of a tree. We denote a graph as a tuple <span class="math notranslate nohighlight">\(G = (V, E)\)</span>, where <span class="math notranslate nohighlight">\(V\)</span> is a set of vertices, and <span class="math notranslate nohighlight">\(E\)</span> is a set of edges, connecting two vertices. We call a graph undirected if the edges have no orientation.</p>
<p>In this section we deal with a special type of undirected graph, namely a tree.</p>
<p><strong>Definition</strong> A tree is an undirected graph <span class="math notranslate nohighlight">\((G, E)\)</span> in which any two vertices are connected by a unique simple path (in a simple path all vertices are distinct).</p>
<p>We designate one vertex in the tree as root. The parent of a vertex <span class="math notranslate nohighlight">\(v\)</span> is the vertex directly connected to the root on the unique path to the root. The children of a verte <span class="math notranslate nohighlight">\(v\)</span> are those vertices for which <span class="math notranslate nohighlight">\(v\)</span> is a parent. We denote the set of children of <span class="math notranslate nohighlight">\(v\)</span> by <span class="math notranslate nohighlight">\(\mathcal{C}(v)\)</span>.</p>
<p>We say that a vertex is a leaf if it has no children. We denote the set of leafs as <span class="math notranslate nohighlight">\(\mathcal{L}\)</span>.</p>
<p>The level <span class="math notranslate nohighlight">\(\ell(v)\)</span> of a vertex <span class="math notranslate nohighlight">\(v\)</span> is the number of edges on the direct path from <span class="math notranslate nohighlight">\(v\)</span> to the root <span class="math notranslate nohighlight">\(r\)</span>. The root itself has level <span class="math notranslate nohighlight">\(0\)</span>, its children have level <span class="math notranslate nohighlight">\(1\)</span>. The depth of a tree is the maximum over all levels in the tree, that is <span class="math notranslate nohighlight">\(\text{depth} := \max_{v\in V}\ell(v)\)</span>.</p>
<p>For simplicity in this section we assume that we have <span class="math notranslate nohighlight">\(N\)</span> points <span class="math notranslate nohighlight">\(x_i\in [0, 1]^d\)</span>, <span class="math notranslate nohighlight">\(i=1,\dots, N\)</span>, <span class="math notranslate nohighlight">\(d=2, 3\)</span>. By <span class="math notranslate nohighlight">\(J:=\{1, \dots, N\}\)</span> we denote the corresponding index set.</p>
<section id="cluster-trees">
<h2>Cluster Trees<a class="headerlink" href="#cluster-trees" title="Permalink to this headline">#</a></h2>
<p>A cluster tree is a tree over the index set <span class="math notranslate nohighlight">\(J\)</span> in which each vertex <span class="math notranslate nohighlight">\(v\)</span> is associated with an index set <span class="math notranslate nohighlight">\(J_v\subset \)</span>J$ satisfying the following conditions.</p>
<ul class="simple">
<li><p>The index set of the root <span class="math notranslate nohighlight">\(r\)</span> of the tree is <span class="math notranslate nohighlight">\(J\)</span>.</p></li>
<li><p>For each vertex <span class="math notranslate nohighlight">\(v\)</span> that is not a leaf the following two conditions hold</p>
<ul>
<li><p>The index sets of the children of <span class="math notranslate nohighlight">\(v\)</span> are disjoint, that is for <span class="math notranslate nohighlight">\(c, c'\in \mathcal{C}(v)\)</span> and <span class="math notranslate nohighlight">\(c\neq c'\)</span> we have that <span class="math notranslate nohighlight">\(J_c\cap J_{c'} = \emptyset\)</span>.</p></li>
<li><p>The union of the index sets of the children are identical to the index set of the parent, that is <span class="math notranslate nohighlight">\(J_v = \bigcup_{c\in\mathcal{C}(v)} J_c\)</span>.</p></li>
</ul>
</li>
<li><p>For each vertex <span class="math notranslate nohighlight">\(v\)</span> that is not a leaf the number of children is larger than one, that is <span class="math notranslate nohighlight">\(|\mathcal{C}(v)| &gt; 1\)</span>.</p></li>
<li><p>No vertex is associated with the empty set, that is <span class="math notranslate nohighlight">\(|J_v| &gt; 0\)</span> for all <span class="math notranslate nohighlight">\(v\in V\)</span>.</p></li>
</ul>
<p>In the following we implement simple data structures to construct a cluster tree. We have two classes, a bounding box class that stores geometric bounding boxes, and a Node class that stores an index set, allows subdivision and returns depth and leaf information.</p>
<p>The most important part is the subdivision. For subdivision we choose the dimension along which the bounding box is longest. We then compute the mean of the points in the index set along this dimension and separate the points by those who are smaller than the mean and those which are larger. From these we construct two new nodes.</p>
<p>There can be the pathological case that all points are aligned along aline. Then this strategy would leave one of the two new index sets empty. In that case we try to subdivide across the other dimension. If that fails as well we raise an exception since in that case all points in the index set are identical.</p>
<p>The recursive partitioning proceeds until the children have fewer than a given parameter <code class="docutils literal notranslate"><span class="pre">nmin</span></code> indices. This is chosen by the user and determines the depth of the tree.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">BoundingBox</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Store a bounding box for a two dimensionsal region.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lower_left</span><span class="p">,</span> <span class="n">upper_right</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define a bounding box.</span>
<span class="sd">        </span>
<span class="sd">            lower_left and upper_right are tuples of floats that</span>
<span class="sd">            determine the lower left and upper right corner of the</span>
<span class="sd">            bounding box.       </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lower_left</span> <span class="o">=</span> <span class="n">lower_left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">upper_right</span> <span class="o">=</span> <span class="n">upper_right</span>

    <span class="k">def</span> <span class="nf">longest_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the longest dimension.&quot;&quot;&quot;</span>

        <span class="n">xlen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_right</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ylen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_right</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_left</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">xlen</span> <span class="o">&gt;=</span> <span class="n">ylen</span> <span class="k">else</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">subdivide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">separator</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Subdivide a bounding box along the given dimension.</span>
<span class="sd">        </span>
<span class="sd">            The parameter dim is either 0 (x-axis) or 1 (y-axis). The</span>
<span class="sd">            subdivision proceeds along this axis.</span>

<span class="sd">            The value separator specifies the point at which to divide up</span>
<span class="sd">            the bounding box.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

            <span class="n">lower_left1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_left</span>
            <span class="n">upper_right1</span> <span class="o">=</span> <span class="p">(</span><span class="n">separator</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_right</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="n">lower_left2</span> <span class="o">=</span> <span class="p">(</span><span class="n">separator</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_left</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">upper_right2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_right</span>

        <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

            <span class="n">lower_left1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_left</span>
            <span class="n">upper_right1</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">upper_right</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">separator</span><span class="p">)</span>

            <span class="n">lower_left2</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lower_left</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">separator</span><span class="p">)</span>
            <span class="n">upper_right2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_right</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">BoundingBox</span><span class="p">(</span><span class="n">lower_left1</span><span class="p">,</span> <span class="n">upper_right1</span><span class="p">),</span> 
                <span class="n">BoundingBox</span><span class="p">(</span><span class="n">lower_left2</span><span class="p">,</span> <span class="n">upper_right2</span><span class="p">))</span>
            
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stores information about nodes of a cluster tree and allows</span>
<span class="sd">    subdivision of a node.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">bounding_box</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new node with given parent and indices.</span>
<span class="sd">        </span>
<span class="sd">        The bounding box has the form [(x_1, y_1), (x_2, y_2)]</span>
<span class="sd">        denoting the lower left and upper right point defining the</span>
<span class="sd">        bounding box for the index set.</span>

<span class="sd">        The variable points stores the original point set as Numpy</span>
<span class="sd">        array of shape (2, N).</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span> <span class="o">=</span> <span class="n">bounding_box</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">points</span>

    <span class="k">def</span> <span class="nf">subdivide</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Subdivide node along longest dimension.&quot;&quot;&quot;</span>

        <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="o">.</span><span class="n">longest_dimension</span><span class="p">()</span>

        <span class="n">first_set</span><span class="p">,</span> <span class="n">second_set</span><span class="p">,</span> <span class="n">separator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subdivide_impl</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">first_set</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">second_set</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Subdivision along this axis did not work</span>
            <span class="c1"># Subdivide along the other axis</span>

            <span class="n">dim</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">dim</span> <span class="c1"># Works since dim is either 0 or 1</span>

            <span class="n">first_set</span><span class="p">,</span> <span class="n">second_set</span><span class="p">,</span> <span class="n">separator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subdivide_impl</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">first_set</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">second_set</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">first_set</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">second_set</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Subdivision not possible&quot;</span><span class="p">)</span>

    
        <span class="n">bounding_box1</span><span class="p">,</span> <span class="n">bounding_box2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="o">.</span><span class="n">subdivide</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">separator</span><span class="p">)</span>

        <span class="n">node1</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_set</span><span class="p">,</span> <span class="n">bounding_box1</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span>
        <span class="n">node2</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">second_set</span><span class="p">,</span> <span class="n">bounding_box2</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">expand_to_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nmin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Recursively subdivide until each index set of the descendents is smaller than nmin.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nmin</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subdivide</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">expand_to_tree</span><span class="p">(</span><span class="n">nmin</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">expand_to_tree</span><span class="p">(</span><span class="n">nmin</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">subdivide_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement the subdividison.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No further subdivision possible.&quot;</span><span class="p">)</span>

        <span class="n">median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">])</span>

        <span class="n">first_set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">median</span><span class="p">]</span>
        <span class="n">second_set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">median</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">first_set</span><span class="p">,</span> <span class="n">second_set</span><span class="p">,</span> <span class="n">median</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">leafs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the leaf descendents of the node.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">leafs</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">leafs</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the depth of the tree from the current node.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">depth</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">depth</span><span class="p">())</span>
            




        

    
</pre></div>
</div>
</div>
</div>
<p>The following code presents a simple example of how to use the data structures.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">N</span> <span class="o">=</span> <span class="mi">500</span>
<span class="n">nmin</span> <span class="o">=</span> <span class="mi">20</span>

<span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="n">bounding_box</span> <span class="o">=</span> <span class="n">BoundingBox</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">Node</span><span class="p">([],</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">bounding_box</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span>

<span class="n">root</span><span class="o">.</span><span class="n">expand_to_tree</span><span class="p">(</span><span class="n">nmin</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Depth: </span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">depth</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of leafs: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">leafs</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Depth: 5
Number of leafs: 32
</pre></div>
</div>
</div>
</div>
<p>In the following we discretise the unit circle, generate the corresponding cluster tree and draw the associated leaf boxes.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="o">%</span><span class="k">matplotlib</span> inline

<span class="n">N</span> <span class="o">=</span> <span class="mi">1001</span>
<span class="n">nmin</span> <span class="o">=</span> <span class="mi">10</span>

<span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">N</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
<span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">z</span><span class="p">)])</span>
<span class="n">lower_left</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.1</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.1</span><span class="p">)</span>
<span class="n">upper_right</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">)</span>
<span class="n">bounding_box</span> <span class="o">=</span> <span class="n">BoundingBox</span><span class="p">(</span><span class="n">lower_left</span><span class="p">,</span> <span class="n">upper_right</span><span class="p">)</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">Node</span><span class="p">([],</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">bounding_box</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">expand_to_tree</span><span class="p">(</span><span class="n">nmin</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">node_to_patch</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper function that turns a node into a matplotlib rectangle patch.&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Rectangle</span>

    <span class="n">lower_left</span><span class="p">,</span> <span class="n">upper_right</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">bounding_box</span><span class="o">.</span><span class="n">lower_left</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">bounding_box</span><span class="o">.</span><span class="n">upper_right</span><span class="p">)</span>

    <span class="n">origin</span> <span class="o">=</span> <span class="n">lower_left</span>
    <span class="n">width</span> <span class="o">=</span> <span class="n">upper_right</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">lower_left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">height</span> <span class="o">=</span> <span class="n">upper_right</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">lower_left</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">Rectangle</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="n">leafs</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">leafs</span><span class="p">()</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">lower_left</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">upper_right</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">lower_left</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">upper_right</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">leafs</span><span class="p">:</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span>
        <span class="n">node_to_patch</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span>
    <span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="s1">&#39;r.&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&lt;matplotlib.lines.Line2D at 0x10fb80b20&gt;]
</pre></div>
</div>
<img alt="_images/partitioning_10_1.png" src="_images/partitioning_10_1.png" />
</div>
</div>
<p>The figure demonstrates how the partitioning refines around the circle, attempting to keep similar numbers of points per box. Cluster trees are simple and as shown above, easy to implement. However, their non-uniform structure is not suitable for all types of applications. This is addressed by Octrees.</p>
</section>
<section id="octrees">
<h2>Octrees<a class="headerlink" href="#octrees" title="Permalink to this headline">#</a></h2>
<p>An octree (or quadtree in two dimensions) is a regular geometric partitioning. Instead of balancing the number of points per box an Octree/Quadtree subdivides a cube/square into 8/4 identically sized child cube/squares. The advantage is a uniform data structure. The boxes on a given level are all identical, making this structure ideal for methods that rely on this uniformity on each level.</p>
<p>We will not go into implementational details here. Even though Octrees/Quadtrees are simple in principle efficient indexing of them is an interesting problem that is solved by Morton encoding, which is based on Z-curve traversals of the tree. This topic leads very much into the realm of computer graphics and associated topics.</p>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="low_rank_compression.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Low rank compressibility</p>
        </div>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Timo Betcke<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>